# Алгоритм поиска пути для CodeSide (RAIC2019)
## Задача
Задачей алгоритма было нахождение кратчайшего пути для юнита в заданную точку на карте.
Длина пути - время в тиках, которое необходимо, что по этому пути пройти.
## Описание идеи
Так как длина пути измеряется в тиках, для ускорения поиска хотелось бы преобразовать данную задачу в задачу поиска пути на невзвешенном графе.
Рассмотрим все возможные переходы юнита за один тик:

* По горизонтали
  * Движение влево: dx = `-1/6..0`
  * Движение вправо: dx = `0..1/6`
* По вертикали
  * Прыжок
    * Обычный: dy = `1/6`
    * От батута: dy = `1/3`
  * Падение: dy = `-1/6`
  
Можно заметить, что все все расстояния кратны 1/6. Благодаря этому наблюдению можно разбить каждый тайл на сетку 6х6 и искать пути только между вершинами полученной сетки.

Чтобы правильно обрабатывать прыжок в поиске пути, нам также необходимо хранить количество тиков, в течении которого мы можем двигаться вверх.

Получилось следующее состояния в поиске пути (вершина абстрактного графа):

* **x**, **y** - координаты узла сетки
* **t** - время в тиках, в течении которого мы можем двигаться вверх
* **p** - тип текущего прыжка (имеет смысл только если t > 0)
  * **0** - обычный прыжок
  * **1** - прыжок от батута
  
Оценим количество возможных состояний:

*  0 <= **x** <= 6 * 40
*  0 <= **y** <= 6 * 30
*  0 <= **t** <= 32 (мы находимся в прыжке только если t > 0, а значит состояния с t = 33  не существует)
*  0 <= **p** <= 1

Суммарное количество состояний (6 * 40 + 1) * (6 * 40 + 1) * 33 * 2 = 2_878_986

Рассмотрим переходы в этом графе:

0) (-1, 0) - движение влево
1) (1, 0) - движение вправо
2) (-1, 1) - начало прыжка влево
3) (1, 1) - начало прыжка право
4) (0, 1) - начало прыжка вверх
5) (-1, -1) - падение влево
6) (1, -1) - падение вправо
7) (0, -1) - падение вниз
8) (-1, 1) - продолжение прыжка влево
9) (1, 1) - продолжение прыжка вправо
10) (0, 1) - продолжение прыжка вверх
11) (-1, 2) - начало прыжка влево с батута
12) (1, 2) - начало прыжка вправо с батута
13) (0, 2) - начало прыжка вверх с батута
14) (-1, 2) - продолжение прыжка влево с батута
15) (1, 2) - продолжение прыжка вправо с батута
16) (0, 2) - продолжение прыжка вверх с батута
17) (0, 0) - прекращение прыжка с батута "ударом головой юнита об потолок"

Здесь есть парочка необычных моментов:

* Разделение прыжков на *начало* и *продолжение*. Это сделано для оптимизации, детальнее потом.
* Ход номер 17 - без этого хода бот не будет знать о том, что есть способ прервать прыжок с батута.

Рассмотрим следующую функцию:

`bool IsValidMove(x, y, move)` - можно ли сделать переход **move** из точки (**x**, **y**). В этой функции проверяется только разрешает ли нам карта совершить данный ход при каких-либо значениях параметров **t** и **p**. Так как разных комбинаций входных параметров всего (6 * 40 + 1) * (6 * 30 + 1) * 18 = 785_178, мы можем предпосчитать все возможные ответы.

Теперь в самом поиске при переборе перехода мы просто проверяем, что ход валиден используя приведенную выше функцию, затем делаем дополнительную проверку, что ход допустим при текущих **t** и **p**. Если ход валиден, то применяем переход к состоянию и получаем новое состояние.

Разделение прыжков на *начало* и *продолжение* позволило нам предпосчитать проверку валидности хода связанную с ограничениями карты, а во время поиска проверять нужно только параметры **t** и **p**.

Суммарное количетсво переходов = количество состояний * 18 = 51_821_748.

Для поиска пути я использовал алгоритм BFS с асимптотикой O(E + V).
Из-за того, что сложные проверки удалось предпосчитать, а многие состояния (и переходы из них) недостижимы, выбранный подход к поиску пути работает довольно быстро.

Так как по памяти были довольно жесткие ограничения, многое хранится в битсетах. 

Код связанный с поиском пути в папке Navigation.





